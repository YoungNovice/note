### ACID
* 原子性 Atomicity 事物要么全部完成 要么不完成
* 一致性 Consistency 
* 隔离性 Isolation 两个事物之间的隔离程度
* 持久性 Durability 事物完成后 对该事务的处理将持久保存在数据库中

### 丢失更新问题
前提： 数据库中同时有多个事物在运行中
1. 条件两个事物操作同一条数据 `一个提交 一个回滚` 那么最终的结果是什么呢
举个栗子 ： 消费问题 10000元成本 A事物用网银支付1000 B事物用支付宝支付1000
A事物提交 B事物回滚  那么最终的结果 应该是9000 但是如果是B 事物后回滚的那么结果
就还是10000元 A的事物操作被B给回滚了 这是有问题的， 不过这类丢失更新问题数据库
层面已经解决

2. 两个事物操作同一条数据 `两个都提交` 那么会有什么问题
举个栗子： 消费问题 10000元成本 A事物用网银支付1000 B事物用支付宝支付10000
（B并无知道A花钱了所以它以为可以用10000 之际上只有9000可以用）A先提交 B后提交
那么最后结果是0元 实际上这是不对的系统超支付了1000元

### 隔离级别
* 脏读 一个事物可以读取到另一个事物未提交的数据
* 读/写提交 一个事物只可以读取到另一个事物已经提交的数据
* 可重复读 
* 序列化

1. A事物读取到B事物未提交的数据 然后B事物回滚 A提交 那么A的结果肯定是错误的
eg : 一共9000 B用1000 A用1000 B回滚A提交结果是8000 但是正确的结果应为9000

2. A事物读取到BC事物已提交的数据 但是A读取到B提交的数据 和到读取C提交的数据
的两个结果是不一样的，也就是A读取到的数据是一个变化的值，它是不可以重读的
eg ：一共9000 A用1000 B用1000 B提交 A再用1000（因为B提交了所以A是知道结果是9000）
C 再用1000（因为C提交了所以A知道结果是8000）
那么问题来了 A再B提交之后和再C提交之后读取出来的总数是一个变化的值 所以对于A事物说
就算让他只能读取到别人已提交的数据 它可能读取的也是一个经常变化的结果 这显然不好

3. 可重复读针对数据库记录的`同一条数据`进行一个序列化的操作，通俗的说就是同条数据
只有一个事物可以拿去用 事物完成后才能给别的事物用, 这样就可以保证同一条数据的一致性
但是但是可重复读只可以解决同一个数据的事物一致性问题
_由于数据库并不止是针对一条数据进行读写操作 在很多情况下 数据库需要同时对多条数据进行读写_
这时候会产生`幻读`现象 

4. 事物B查询消费结果有10条 事物A消费了一笔 事物B打印消费发现有11条数据 莫名其妙的多了一条
怎么解决这个问题 其实很简单 就是sql一个一个的顺序执行就完事了
叫做可序列化（可序列化是用来解决这种幻读问题）

| 隔离级别 | 脏读 | 不可重读 | 幻读 |
| :----------: | :---------- : | :----------: | :----------: |
| 脏读 | yes | yes | yes |
| 读/写提交 | no | yes | yes |
| 可重复读 |no | no | yes |
| 序列化 | no | no | no |

### 传播特性
* 传播特性指的是方法之间调用事物的策略问题

| 传播行为 | 含义 | 备注 |
| :----------: | :---------- : | :----------: | 
| REQUIRED | 当方法调用时，不存在事物就创建事物，存在就使用之前的事物 | Spring默认的传播行为 |
| SUPPORTS | 当调用方法时，不存在事物就不用， 存在就使用 | - |
| MANDATORY | 方法必须在事物内运行 | 没有事物会抛异常|
| REQUIRED_NEW | 不管之前有没有事物 都会在新的事物中运行 | 事物管理器总会打开新事物 |
| NOT_SUPPORTED | 不支持事物， 不存在不创建 存在就挂起当前事物，直到方法结束恢复事物 | 适用于不需要事物的场景 |
| NEVER | 不支持事物， 只能在非事物环境中运行 | 如果方法存在事物会报异常 |
| NESTED |嵌套事物， 调用方法如果抛出异常值回滚自己内部事物，而不会滚主方法事物 | 实际上分为两种， 如果当前数据库支持保存点
那么它就会在当前事物上使用保存点技术， 如果发生异常将方法执行的sql回滚到保存点上，而不是全部回滚， 如果不支持保存点就使用REQURES_NEW行为处理|
 
* tips : 需要关注 REQUIRE_NEW 和 NESTED 两个行为

### 几个关于事物的经典问题

1. @Transactional的自调用失效问题
* 条件： 同一个类型一个事物方法调用另一个事物方法 另一个方法的事物根本不会起作用
* 为什么： 还得从aop说起 归根结题是动态代理的问题， 当我我们想要通知起作用必须要用
代理对象调用方法才行， 而不是真实对象。
* 怎么办： 
   > 1.将两个方法归到不同的类中 
   > 2.从spring容器中获取当前对象的代理对象ctx.getBean(xx) 然后用代理对象调用方法（不推荐）
   
2. 在Controller层调用多个事物方法   
* 例如：要保存学生 和 老师两个关联信息
* 结果我们在controller中分别调用了保存学生 和 保存老师的方法
* 而一个service方法完成后 它就会释放该事物，那么前后两个方法分别在不同的事物完成
* 一旦中间发生异常数据的一致性没法保证

3. 过长时间占用事物
* 在Service方法搞一些比较耗时操作 特别是IO和复杂计算 要知道数据库事物资源是比较宝贵的资源

4. 错误捕获异常导致事物没法回滚
* 在service层自己用try catch捕获了异常， 这样spring就没法知道事物需要回滚
* 如果确实要自己处理异常， 请在catch异常后抛出一个能使spring事物回滚的异常

   















 



 
 