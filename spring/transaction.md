### ACID
* 原子性 Atomicity 事物要么全部完成 要么不完成
* 一致性 Consistency 
* 隔离性 Isolation 两个事物之间的隔离程度
* 持久性 Durability 事物完成后 对该事务的处理将持久保存在数据库中

### 丢失更新问题
前提： 数据库中同时有多个事物在运行中
1. 条件两个事物操作同一条数据 `一个提交 一个回滚` 那么最终的结果是什么呢
举个栗子 ： 消费问题 10000元成本 A事物用网银支付1000 B事物用支付宝支付1000
A事物提交 B事物回滚  那么最终的结果 应该是9000 但是如果是B 事物后回滚的那么结果
就还是10000元 A的事物操作被B给回滚了 这是有问题的， 不过这类丢失更新问题数据库
层面已经解决

2. 两个事物操作同一条数据 `两个都提交` 那么会有什么问题
举个栗子： 消费问题 10000元成本 A事物用网银支付1000 B事物用支付宝支付10000
（B并无知道A花钱了所以它以为可以用10000 之际上只有9000可以用）A先提交 B后提交
那么最后结果是0元 实际上这是不对的系统超支付了1000元

### 隔离级别
* 脏读 一个事物可以读取到另一个事物未提交的数据
* 读/写提交 一个事物只可以读取到另一个事物已经提交的数据
* 可重复读 
* 序列化

1. A事物读取到B事物未提交的数据 然后B事物回滚 A提交 那么A的结果肯定是错误的
eg : 一共9000 B用1000 A用1000 B回滚A提交结果是8000 但是正确的结果应为9000

2. A事物读取到BC事物已提交的数据 但是A读取到B提交的数据 和到读取C提交的数据
的两个结果是不一样的，也就是A读取到的数据是一个变化的值，它是不可以重读的
eg ：一共9000 A用1000 B用1000 B提交 A再用1000（因为B提交了所以A是知道结果是9000）
C 再用1000（因为C提交了所以A知道结果是8000）
那么问题来了 A再B提交之后和再C提交之后读取出来的总数是一个变化的值 所以对于A事物说
就算让他只能读取到别人已提交的数据 它可能读取的也是一个经常变化的结果 这显然不好

3. 可重复读针对数据库记录的`同一条数据`进行一个序列化的操作，通俗的说就是同条数据
只有一个事物可以拿去用 事物完成后才能给别的事物用, 这样就可以保证同一条数据的一致性
但是但是可重复读只可以解决同一个数据的事物一致性问题
_由于数据库并不止是针对一条数据进行读写操作 在很多情况下 数据库需要同时对多条数据进行读写_
这时候会产生`幻读`现象 

4. 事物B查询消费结果有10条 事物A消费了一笔 事物B打印消费发现有11条数据 莫名其妙的多了一条
怎么解决这个问题 其实很简单 就是sql一个一个的顺序执行就完事了
叫做可序列化（可序列化是用来解决这种幻读问题）

### 传播特性














 



 
 