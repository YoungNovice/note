| 隔离级别 | 脏读 | 不可重读 | 幻读 |
| :----------: | :---------- : | :----------: | :----------: |
| 脏读 | yes | yes | yes |
| 读/写提交 | no | yes | yes |
| 可重复读 |no | no | yes |
| 序列化 | no | no | no |

### 传播特性
* 传播特性指的是方法之间调用事物的策略问题
| 传播行为 | 含义 | 备注 |
| :----------: | :---------- : | :----------: | 
| REQUIRED | 当方法调用时，不存在事物就创建事物，存在就使用之前的事物 | Spring默认的传播行为 |
| SUPPORTS | 当调用方法时，不存在事物就不用， 存在就使用 | - |
| MANDATORY | 方法必须在事物内运行 | 没有事物会抛异常|
| REQUIRED_NEW | 不管之前有没有事物 都会在新的事物中运行 | 事物管理器总会打开新事物 |
| NOT_SUPPORTED | 不支持事物， 不存在不创建 存在就挂起当前事物，直到方法结束恢复事物 | 适用于不需要事物的场景 |
| NEVER | 不支持事物， 只能在非事物环境中运行 | 如果方法存在事物会报异常 |
| NESTED |嵌套事物， 调用方法如果抛出异常值回滚自己内部事物，而不会滚主方法事物 | 实际上分为两种， 如果当前数据库支持保存点
那么它就会在当前事物上使用保存点技术， 如果发生异常将方法执行的sql回滚到保存点上，而不是全部回滚， 如果不支持保存点就使用REQURES_NEW行为处理|
 
* tips : 需要关注 REQUIRE_NEW 和 NESTED 两个行为

### 几个关于事物的经典问题

1. @Transactional的自调用失效问题
* 条件： 同一个类型一个事物方法调用另一个事物方法 另一个方法的事物根本不会起作用
* 为什么： 还得从aop说起 归根结题是动态代理的问题， 当我我们想要通知起作用必须要用
代理对象调用方法才行， 而不是真实对象。
* 怎么办： 
   > 1.将两个方法归到不同的类中 
   > 2.从spring容器中获取当前对象的代理对象ctx.getBean(xx) 然后用代理对象调用方法（不推荐）
   
2. 在Controller层调用多个事物方法   
* 例如：要保存学生 和 老师两个关联信息
* 结果我们在controller中分别调用了保存学生 和 保存老师的方法
* 而一个service方法完成后 它就会释放该事物，那么前后两个方法分别在不同的事物完成
* 一旦中间发生异常数据的一致性没法保证

3. 过长时间占用事物
* 在Service方法搞一些比较耗时操作 特别是IO和复杂计算 要知道数据库事物资源是比较宝贵的资源

4. 错误捕获异常导致事物没法回滚
* 在service层自己用try catch捕获了异常， 这样spring就没法知道事物需要回滚
* 如果确实要自己处理异常， 请在catch异常后抛出一个能使spring事物回滚的异常

   
